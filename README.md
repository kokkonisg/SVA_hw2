# Εισαγωγή

Το αντικείμενο της εργασίας ήταν η σχεδίαση ενός απαριθμητή (up-down) και μιας
σύγχρονης μνήμης FIFO σε SystemVerilog καθώς και ο έλεγχος τους
χρησιμοποιώντας SVAs. Η σχεδίαση έγινε με το λογισμικό “ _Questa*-Intel® FPGA
Edition_ ”.

# Απαριθμητής

Η σχεδίαση του απαριθμητή ακολουθεί μία απλή λογική όπου η 16-bit έξοδος του
αυξάνεται ή μειώνεται σε κάθε παλμό του ρολογιού ανάλογα με το σήμα _updn_cnt_
και εφόσον είναι ενεργοποιημένο το σήμα _count_enb._ Επίσης δίνεται η δυνατότητα
εισαγωγής δεδομένων για να χρησιμοποιηθούν ως αφετηρία απαρίθμησης.

Χρησιμοποιώντας assertions ελέγχεται η συμπεριφορά του μοντέλου στις παρακάτω
περιπτώσεις:

1. Στην περίπτωση επανεκκίνησης ( _rst__ low) θα πρέπει να μηδενίζεται άμεσα η
    έξοδος.
2. Στην περίπτωση εισαγωγής δεδομένων ( _ld_cnt_ low) θα πρέπει να
    εμφανίζονται στην έξοδο τα δεδομένα εισόδου μετά από ένα κύκλο ρολογιού.
3. Όταν είναι ενεργοποιημένος ο απαριθμητής ( _count_enb_ high) θα πρέπει να
    αυξάνονται ή να μειώνονται τα δεδομένα στην έξοδο ανάλογα με την τιμή του
    σήματος _updn_cnt_.
4. Τέλος όταν δεν είναι ενεργοποιημένος ο απαριθμητής τα δεδομένα στην έξοδο
    θα πρέπει να παραμένουν σταθερά.

Στο testbench του μοντέλου ελέγχεται η κανονική λειτουργία του απαριθμητή, η
μετάβαση από την μικρότερη στην μέγιστη τιμή (και αντίστροφα) και η εισαγωγή
δεδομένων όταν είναι ενεργοποιημένος καθώς και απενεργοποιημένος.


# Μνήμη FIFO

Για την σχεδίαση της μνήμης χρησιμοποιήθηκαν δύο δείκτες για την γραφή και την
ανάγνωση δεδομένων από αυτήν, οι οποίοι αυξάνονται στην θετική ακμή του
ρολογιού εάν το αντίστοιχο σήμα είναι ενεργοποιημένο. Επιπλέον εξάγονται τα
σήματα _full_ και _empty_ τα οποία ενεργοποιούνται όταν η μνήμη είναι γεμάτη ή άδεια
αντίστοιχα. Τέλος επισημαίνεται ότι η σχεδίαση είναι πλήρως παραμετροποιημένη ως
προς το μέγεθος και το πλήθος των λέξεων που θα αποθηκεύονται σε αυτήν.

Μια ειδική περίπτωση είναι αυτή της ταυτόχρονης γραφής και ανάγνωσης
δεδομένων, η οποία είναι πάντα επιτρεπτή ακόμα και όταν απευθύνεται στο ίδιο κελί
της μνήμης, όπου δηλαδή οι δύο δείκτες είναι ίσοι. Αυτό γίνεται διότι η μόνη στιγμή
που οι δείκτες είναι ίσοι είναι όταν η μνήμη είναι γεμάτη ή άδεια, αλλά στην
περίπτωση αυτή ένα από τα δύο αιτήματα δεν θα γίνει δεκτό (το αίτημα ανάγνωσης
όταν είναι άδεια και της γραφής όταν είναι γεμάτη). Επομένως στην ουσία δεν
συμβαίνουν ταυτόχρονα τα δύο γεγονότα και ο μετρητής _cnt_ θα πρέπει να
αυξηθεί/μειωθεί κανονικά. Για αυτό υπάρχει και ο επιπλέον έλεγχος πριν την
μεταβολή του (γραμμές 24 & 31 στο αρχείο _fifo.sv_ ).

Assertions χρησιμοποιήθηκαν για τον έλεγχο της σχεδίασης στις παρακάτω
περιπτώσεις:

1. Σε περίπτωση επανεκκίνησης το περιεχόμενο της μνήμης θα πρέπει να
    μηδενίζεται όπως και οι δείκτες, με αποτέλεσμα η μνήμη να είναι άδεια.
2. Όταν η μνήμη είναι άδεια, και μόνο τότε, θα πρέπει να ενεργοποιείται το σήμα
    _empty_ ενώ όταν είναι γεμάτη να ενεργοποιείται αντίστοιχα το σήμα _full._
3. Όταν υπάρχει αίτημα γραφής αλλά η μνήμη είναι γεμάτη θα πρέπει να
    απορρίπτεται χωρίς να γίνει κάποια αλλαγή στα δεδομένα και ο αντίστοιχος
    δείκτης να παραμένει ίδιος.
4. Όταν υπάρχει αίτημα ανάγνωσης αλλά η μνήμη είναι άδεια θα πρέπει να
    απορρίπτεται χωρίς να γίνει κάποια αλλαγή στα δεδομένα και ο αντίστοιχος
    δείκτης να παραμένει ίδιος.
5. Όταν υπάρχει αίτημα γραφής και δεν είναι γεμάτη η μνήμη τότε θα πρέπει να
    αυξάνεται ο αντίστοιχος δείκτης.
6. Όταν υπάρχει αίτημα ανάγνωσης και δεν είναι άδεια η μνήμη τότε θα πρέπει
    να αυξάνεται ο αντίστοιχος δείκτης.
7. Όταν υπάρχει ταυτόχρονα αίτημα γραφής και ανάγνωσης, στην περίπτωση που
    η μνήμη δεν είναι ούτε γεμάτη ούτε άδεια αυτή πρέπει να λειτουργεί κανονικά
    και με τους δύο δείκτες να αυξάνονται. Αντίθετα εάν κάποιο αίτημα αποτύχει
    επειδή η μνήμη είναι ή άδεια ή γεμάτη τότε θα πρέπει να αυξηθεί μόνο ο
    δείκτης του αντίστοιχου αιτήματος που πέτυχε.

Στο testbench του μοντέλου ελέγχεται η κανονική λειτουργία της μνήμης, η
ταυτόχρονη γραφή και ανάγνωση καθώς και μεμονωμένα τα αιτήματα όταν αυτή
είναι γεμάτη και άδεια.



